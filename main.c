// Biblioteca padrão do Esp32
#include <stdio.h>
#include <string.h>

// Biblioteca para o Sistema Operacioal em Tempo Real (FreeRTOS)
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2c.h"
#include "esp_log.h"
#include "sdkconfig.h"

// Bibliotecas para o OLED SSD1309 (128x64px)
#include "u8g2.h"
#include "wire.h"

// Macros para o SLAVE 
#define I2C_SLAVE_SCL_IO          13     // GPIO número para SCL
#define I2C_SLAVE_SDA_IO          12     // GPIO número para SDA
#define I2C_SLAVE_NUM             I2C_NUM_0 // número da interface/barramento i2c usada 
#define I2C_SLAVE_TX_BUF_LEN      (2 * 128) // tamanho buffer de transmissão de dados (256 bytes)
#define I2C_SLAVE_RX_BUF_LEN      (2 * 128) // tamanho buffer de recepção de dados (256 bytes)
#define SLAVE_ADDR                0x08   // Endereço I2C do escravo

// Macros para o OLED
#define I2C_OLED_NUM_1 I2C_NUM_1 
#define I2C_OLED_SCL_IO_1 22
#define I2C_OLED_SDA_IO_1 21
#define I2C_OLED_FREQ_HZ_1 100000 // velocidade em que o clock será usado 
#define I2C_OLED_ADDR 0x3C // endereço de i2c do OLED

//
static const char *TAG = "I2C_Slave";

// Construtor do Display; U8G2_SSD1309_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0);

// Estrutura do Slave
typedef struct {
    float rpm;
    float velocidade;
    int nivelCombustivel;
} message_t; 

// 'painel_bomba_24_bitmap', 128x64px; const unsigned char
 static const uint8_t epd_bitmap_painel_bomba [] PROGMEM = {
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x80, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xE0, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 
  0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xE0, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 
  0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xE0, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC1, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x41, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x5F, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xBF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xE7, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x0F, 0xC0, 0xFF, 
  0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 
  0xFF, 0x07, 0x80, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x5F, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x01, 0x00, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x7F, 0x00, 0x00, 0xFE, 
  0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0x41, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 
  0x0F, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x80, 0xC1, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 0x3F, 0x00, 0x60, 0xE0, 
  0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 
  0xFF, 0x8F, 0x00, 0xFE, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x0F, 0x83, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x3C, 0xFC, 0xFF, 
  0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 
  0xF7, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xEF, 0xFE, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0x07, 0x9B, 0xBF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xEF, 0x07, 0x83, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x0F, 0xC0, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0x1F, 0xF0, 0xE7, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x3F, 0xFF, 0xFC, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFE, 0xFF, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x5C, 0xEC, 0xF8, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x18, 0x70, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x61, 0x38, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x0F, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x0F, 0xC2, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xC0, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x87, 0x0F, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xF4, 0xBF, 0xF9, 0xFD, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x3F, 0xFF, 0xFF, 0xF3, 
  0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 
  0xDF, 0xFF, 0xFF, 0xCF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xBF, 0xF7, 0xFF, 0xFF, 0xBF, 0xC1, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 0xF7, 0xFF, 0xFF, 0xBF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF,
};

// variáveis oled
int progress = 0; 

u8g2_t u8g2;

void i2c_oled_init() {

    // Inicializa o i2c do Display
    i2c_config_t conf_oled = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_OLED_SDA_IO_1, 
        .scl_io_num = I2C_OLED_SCL_IO_1,
        .sda_pullup_en = GPIO_PULLUP_ENABLE, 
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_OLED_FREQ_HZ_1, 
        // Velocidade do clock 
    };
    i2c_param_config(I2C_OLED_NUM_1, &conf_oled);
    i2c_driver_install(I2C_OLED_NUM_1, conf_oled.mode, 0, 0, 0);

    // Inicializa o Display
    u8g2_Setup_ssd1306_i2c_128x64_noname_f(
        &u8g2, U8G2_R0, 
        u8x8_byte_hw_i2c, 
        u8x8_gpio_and_delay_esp32
    );    
    u8g2_InitDisplay(&u8g2);
    u8g2_SetPowerSave(&u8g2, 0);

    updateData();

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

void updateData() {

    u8g2.clearBuffer();

    u8g2.firstPage();

    processData();

    do {

        data();

        printData();

        u8g2.setColorIndex(1);
        u8g2.drawXBMP(0,0,128/8,64,epd_bitmap_painel_bomba);
        u8g2.setColorIndex(0);
        u8g2.drawBox(1,2,122,8);
        u8g2.serColorIndex(1);
        u8g2.drawBox(1,2,map(progress,0,100,0,122),8);

    } while (u8g2.nextPage());
    
    u8g2.sendBuffer();

    delay(500);

    if (progress < 100) {
        progress++;
    } else {
        progress = 0;
    }
}

void data() {

    u8g2.setFont(u8g2_font_4x6_tn);

    u8g2.setCursor(10, 28);
    u8g2.print(message->rpm);

    u8g2.setCursor(52, 28);
    //u8g.print(message->temperatura);

    u8g2.setCursor(13, 57);
    u8g2.print(message->velocidade);
}

void printData() {

    u8g2.setFont(u8g2_font_6x10_tf);

    u8g2.drawStr(17, 17, "RPM");

    u8g2.drawStr(64, 17, "TEMP");
    u8g2.drawStr(84, 28, "C");
  
    u8g2.drawStr(31, 44, "VEL");
    u8g2.drawStr(52, 54, "Km/h");
}

void i2c_slave_init() {

    i2c_config_t conf_slave = {
        .mode = I2C_MODE_SLAVE,  // define que ele deve ser operado no modo escravo
        .sda_io_num = I2C_SLAVE_SDA_IO, 
        .sda_pullup_en = GPIO_PULLUP_ENABLE, // ativa os resistores de pull-up internos do dispositivos para o sinal de dados
        .scl_io_num = I2C_SLAVE_SCL_IO,
        .scl_pullup_en = GPIO_PULLUP_ENABLE, // ativa os do sinal de clock 
        .slave.addr_10bit_en = 0, // habilita o endereço de 7 bits (10 por padrão)
        .slave.slave_addr = SLAVE_ADDR, // define o endereço i2c de escravo 
    };
    i2c_param_config(I2C_SLAVE_NUM, &conf_slave); // aplica as configurações especificadas na estrutura
    /*

    - i2c_config_t - configura o hardware do i2c no ESP32 de acordo com os parâmetros fornecidos
    - I2C_SLAVE_NUM - número do barramento i2c
    - &conf_slave - ponteiro para a estrutura de configuração
    
    */

    i2c_driver_install(I2C_SLAVE_NUM, conf_slave.mode, I2C_SLAVE_RX_BUF_LEN, I2C_SLAVE_TX_BUF_LEN, 0); 
    // instala o driver no dispositivo e prepara o hardware para a comunicação

    /*
    
    - Número de barramento
    - Modo de operação
    - os tamanhos dos buffers de recepção transmissão
    - "0" opção de event queue não está sendo usada 
    
    */

}

void processData() {
    uint8_t data[sizeof(message_t)]; // data - variável que armazena os dados recebidos via i2c.  
    while (1) {
        // Recebimento de dados
        int len = i2c_slave_read_buffer(I2C_SLAVE_NUM, data, sizeof(data), portMAX_DELAY);
        // Lê os dados recebidos pelo slave i2c, possui o número e bytes especificados e os armazena no buffer data
        /* 
        
        - número de barramento
        - buffer dos dados armazenados 
        - sizeof(data) - quantidade máxima de dados que o escravo deve ler
        - portMAX_DELAY - a função aguardará até o master envie os dados
        
        */

        // Verificação de dados
        if (len == sizeof(message_t)) {
            // dados estão corretos e exibidos no log
            message_t *message = (message_t *)data;
            // o buffer data é convertido para um ponteiro do tipo message_t
            ESP_LOGI(TAG, "Received data: RPM=%.2f, Velocidade=%.2f, NivelCombustivel=%d", 
                     message->rpm, message->velocidade, message->nivelCombustivel); 
            // ESP_LOGI - usado para exibir os dados 
        } else {
            // dados incorretos e exibido no log
            ESP_LOGE(TAG, "Received data length mismatch. Expected %d, got %d", sizeof(message_t), len);
            // ESP_LOGE - também usado para exibir os dados
        }
    }
}

void app_main() {

    // Inicialização do OLED
    i2c_OLED_init();

    // Inicializar o slave
    i2c_slave_init();

    xTaskCreate(processData, "processData", 2048, NULL, 10, NULL); 
    // cria uma nova tarefa no FreeRTOS, a qual executará o processData
    // Monitorar continuamente os dados recebidos via i2c e processá-los
    /*
    
    - "processData" - o nome da tarefa
    - tamanho da pilha alocada para a tarefa (bytes)
    - argumentos passados para a função de tarefa (NULL)
    - prioridade da tarefa (10)
    - identificador de tarefa (NULL)
    
    */
}